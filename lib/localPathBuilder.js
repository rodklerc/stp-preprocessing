var stream = require('stream'),
    util = require('util');

/**
  * A local path builder transforms an MST generated by CSA to transfer patterns
  * for inter-cluster transport and also for transport to and from border
  * stations. The concept of a "long-distance station" is ignored at the
  * moment.
  * A transfer pattern is an object with two values:
  * tp: the transfer pattern itself, which is just an array of stops.
  * changedCluster: a boolean indicating wether this transfer pattern crosses
  * cluster boundaries
  * @param stop This should be the root of the MST.
  */
var LocalPathBuilder = function (stop, inverseClustering, borderStations) {
  stream.Transform.call(this, {objectMode : true});
  this._allConnections = {};
  this._stop = stop;
  this._inverseClustering = inverseClustering;
  this._connectionCounter = 0;
  this._borderStations = borderStations;
};

util.inherits(LocalPathBuilder, stream.Transform);

LocalPathBuilder.prototype._write = function (connection, encoding, done) {
  // Since we need to process the MST as a whole, we simply build an array of
  // all connections.
  // TODO optimization: we can already filter some connections at this point!
  this._allConnections[connection["@id"]] = connection;
  this._connectionCounter++;
  done();
};

// We do not follow all paths in the MST. If the departure stop is not a
// border station, then we only calculate the optimal route to other stations
// in the same cluster. Otherwise, we also calculate the optimal route to
// border stations of other clusters.
LocalPathBuilder.prototype._shouldFollowPath = function (stop1, stop2) {
  if (!this._borderStations[stop1]) {
    return this._inverseClustering[stop1] == this._inverseClustering[stop2];
  } else {
    // !!! A route between border stations may go via another cluster !!!
    // TODO: speed up taking local patterns into account (cf. paper)!
    return true;
    /*return this._borderStations[stop2] ||
           this._inverseClustering[stop1] == this._inverseClustering[stop2];*/
  }
}

LocalPathBuilder.prototype._flush = function (callback) {
  // Will hold the compacted MST.
  var mst = {};

  // this._allConnections now holds a *full* MST for departure stop this._stop.
  // We will now prune this MST by scanning every path. The path is given
  // by the previous-pointers in the connection data.
  for (var connectionId in this._allConnections) {
    // We will now follow the path starting from the connection with
    // connectionId.
    var previousTripId = null;
    var currentConnection = this._allConnections[connectionId];
    var currentPath = []; // will hold a transfer pattern

    // Not every path in the MST should be saved as a transfer pattern.
    // The definition of a valid path was given earlier.
    var valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);

    // For border stations: only calculate routes to other border stations or
    // stops in the same cluster.
    if (this._borderStations[this._stop] && !this._borderStations[currentConnection.arrivalStop] &&
        this._inverseClustering[this._stop] != this._inverseClustering[currentConnection.arrivalStop]) {
      valid = false;
    }

    // We cannot proceed "past" the root node of the MST, this._stop is the root.
    var finished = this._stop == currentConnection.departureStop;

    var reuse = false;

    currentPath.push(currentConnection.arrivalStop);
    previousTripId = currentConnection["gtfs:trip"]["@id"];

    while (valid && !finished) {
      // We already calculated the transfer patterns starting from
      // currentConnection.arrivalStop. We may reuse this path, since there
      // is only one path to the root (by the definition of "tree").
      if (mst[currentConnection.arrivalStop] != undefined) {
        valid = true;
        finished = true;
        reuse = true;
        currentPath.push(mst[currentConnection.arrivalStop]);
      } else {
        // No transfer occured and we are not yet at the root node, so move
        // to the next (= previous) connection and check if this is a valid
        // move.
        currentConnection = this._allConnections[currentConnection.previous];

        // This check is done purely as a safety guard, should we receive a
        // forest instead of a tree as input.
        if (currentConnection === undefined) {
          valid = false;
          finished = false;
        } else {
          valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);
          finished = this._stop == currentConnection.departureStop;

          // A transfer occured!
          if (currentConnection["gtfs:trip"]["@id"] != previousTripId) {
            currentPath.push(currentConnection.arrivalStop);
            previousTripId = currentConnection["gtfs:trip"]["@id"];
          }
        }
      }
    }

    // Have we found a valid and complete path?
    if (finished && valid) {
      // Two directly connected stops (edge case).
      if (currentPath.length === 0) {
        currentPath = [currentConnection.arrivalStop];
        mst[currentConnection.arrivalStop] = this._stop;
      }
      // Write out the current path and save it in the MST structure.
      var changedCluster = false;
      if (!reuse)
        currentPath.push(this._stop);
      for (var i = 0; i < currentPath.length - 1; i++) {
        if (this._inverseClustering[this._stop] != this._inverseClustering[currentPath[i]]) {
          changedCluster = true;
        }
        mst[currentPath[i]] = currentPath[i+1];
      }
      this.push({tp: currentPath, "changedCluster": changedCluster, stop: this._stop});
    }
  }

  callback();
};

module.exports = LocalPathBuilder;
