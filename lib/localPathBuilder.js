var stream = require('stream'),
    util = require('util');

/**
  * A local path builder transforms a "semi-MST" generated by CSA to transfer patterns
  * for inter-cluster transport and also for transport to and from border
  * stations. The concept of a "long-distance station" is ignored at the
  * moment.
  * WARNING: since the output of CSA isn't really a minimal spanning tree, we
  * also generate non-optimal transfer patterns (which can be filtered later on).
  * A transfer pattern is an object with two values:
  * tp: the transfer pattern itself, which is just an array of stops.
  * changedCluster: a boolean indicating wether this transfer pattern crosses
  * cluster boundaries
  * arrivalTime: arrival time at arrival station
  * @param stop This should be the root of the MST.
  */
var LocalPathBuilder = function (stop, inverseClustering, borderStations) {
  stream.Transform.call(this, {objectMode : true});
  this._allConnections = {};
  this._stop = stop;
  this._inverseClustering = inverseClustering;
  this._connectionCounter = 0;
  this._borderStations = borderStations;
};

util.inherits(LocalPathBuilder, stream.Transform);

LocalPathBuilder.prototype._write = function (connection, encoding, done) {
  // Since we need to process the MST as a whole, we simply build an array of
  // all connections.
  // TODO: for non-border stations: filter connections arriving or departing
  // outside of the current cluster
  this._allConnections[connection["@id"]] = connection;
  this._connectionCounter++;
  done();
};

// We do not follow all paths in the MST. If the departure stop is not a
// border station, then we only calculate the optimal route to other stations
// in the same cluster. Otherwise, we also calculate the optimal route to
// border stations of other clusters.
LocalPathBuilder.prototype._shouldFollowPath = function (stop1, stop2) {
  if (!this._borderStations[stop1]) {
    return this._inverseClustering[stop1] == this._inverseClustering[stop2];
  } else {
    // A route to a border station may follow an "internal" connection of
    // another cluster.
    // TODO: can we speed this up by taking local patterns into account? (cf. paper)
    return true;
  }
}

LocalPathBuilder.prototype._flush = function (callback) {
  console.log('building local paths with ' + this._connectionCounter + ' connections');

  // Will hold the compacted MST.
  var mst = {};

  // this._allConnections now holds a *full* MST for departure stop this._stop.
  // We will now prune this MST by scanning every path. The path is given
  // by the previous-pointers in the connection data.
  for (var connectionId in this._allConnections) {
    // We will now follow the path starting from the connection with
    // connectionId.
    var previousTripId = null;
    var currentConnection = this._allConnections[connectionId];
    var currentPath = []; // will hold a transfer pattern

    // Not every path in the MST should be saved as a transfer pattern.
    // The definition of a valid path was given earlier.
    var valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);

    // For border stations: only calculate routes to other border stations or
    // stops in the same cluster.
    if (this._borderStations[this._stop] && !this._borderStations[currentConnection.arrivalStop] &&
        this._inverseClustering[this._stop] != this._inverseClustering[currentConnection.arrivalStop])
      valid = false;

    // We cannot proceed "past" the root node of the MST, this._stop is the root.
    var finished = this._stop == currentConnection.departureStop;

    while (valid && !finished) {
      // A transfer occured!
      if (currentConnection["gtfs:trip"]["@id"] != previousTripId) {
        currentPath.push(currentConnection.arrivalStop);
        previousTripId = currentConnection["gtfs:trip"]["@id"];
      }

      currentConnection = this._allConnections[currentConnection.previous];

      // This check is done purely as a safety guard, should we receive a
      // forest instead of a tree as input.
      if (currentConnection === undefined) {
        valid = false;
        finished = false;
      } else {
        // No transfer occured and we are not yet at the root node, so move
        // to the next (= previous) connection and check if this is a valid
        // move.
        valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);
        finished = this._stop == currentConnection.departureStop;
      }
    }

    // Have we found a valid and complete path?
    if (finished && valid) {
      // Two directly connected stops (edge case, loop was never executed).
      if (currentPath.length === 0) {
        mst[currentConnection.arrivalStop] = this._stop;
        this.push({tp: [currentConnection.arrivalStop, this._stop],
                   "changedCluster": this._inverseClustering[currentConnection.arrivalStop] != this._inverseClustering[this._stop],
                   stop: this._stop});
      } else {
        // Write out the current path.
        var changedCluster = false;
        currentPath.push(this._stop);
        for (var i = 0; i < currentPath.length - 1; i++) {
          if (this._inverseClustering[this._stop] != this._inverseClustering[currentPath[i]]) {
            changedCluster = true;
          }
        }
        this.push({tp: currentPath, "changedCluster": changedCluster, stop: this._stop});
      }
    }
  }

  callback();
};

module.exports = LocalPathBuilder;
