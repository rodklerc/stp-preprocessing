var stream = require('stream');
var util = require('util');
var Client = require('lc-client');
var async = require('async');
var Fetcher = require('lc-client').Fetcher;
var Planner = require('csa').BasicCSA;

/**
  * A local path builder transforms the MST as generated by CSA to
  * time-independent *local* transfer patterns. These transfer patterns may
  * then be used to construct the full local transfer pattern DAG.
  */
var LocalPathBuilder = function (stop, inverseClustering, borderStations) {
  stream.Transform.call(this, {objectMode : true});
  this._allConnections = {};
  this._stop = stop;
  this._inverseClustering = inverseClustering;
  this._connectionCounter = 0;
  this._borderStations = borderStations;
};

util.inherits(LocalPathBuilder, stream.Transform);

LocalPathBuilder.prototype._write = function (connection, encoding, done) {
  // We simply build an array of connections, which we will then use to generate
  // all possible paths.
  this._allConnections[connection["@id"]] = connection;
  this._connectionCounter++;
  done();
};

LocalPathBuilder.prototype._shouldFollowPath = function (stop1, stop2) {
  if (!this._borderStations[stop1]) {
    return this._inverseClustering[stop1] == this._inverseClustering[stop2];
  } else {
    return this._borderStations[stop2];
  }
}

LocalPathBuilder.prototype._flush = function (callback) {
  console.log('building local paths with ' + this._connectionCounter + ' connections');

  var mst = {};

  // this._allConnections now holds a *full* MST for departure stop this._stop.
  // We will now prune this MST.

  for (var connectionId in this._allConnections) {
    var previousTripId = null;
    var currentConnection = this._allConnections[connectionId];
    var currentPath = [];

    var valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);
    var finished = this._stop == currentConnection.departureStop;

    while (valid && !finished) {
      if (currentConnection["gtfs:trip"]["@id"] != previousTripId) {
        currentPath.push(currentConnection.arrivalStop);
        previousTripId = currentConnection["gtfs:trip"]["@id"];
      }

      if (mst[currentConnection.arrivalStop] != undefined) {
        valid = true;
        finished = true;
      } else {
        currentConnection = this._allConnections[currentConnection.previous];

        // This check is done purely as a safety guard, should we receive a
        // forest instead of a tree as input.
        if (currentConnection === undefined) {
          valid = false;
          finished = false;
        } else {
          valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);
          finished = this._stop == currentConnection.departureStop;
        }
      }
    }

    if (finished && valid) {
      // Two directly connected stops (edge case).
      if (currentPath.length === 0) {
        mst[currentConnection.arrivalStop] = this._stop;
      } else {
        currentPath.push(this._stop);
        for (var i = 0; i < currentPath.length - 1; i++) {
          mst[currentPath[i]] = currentPath[i+1];
        }
      }
      //console.log(currentPath);
    }
  }

  console.log(mst);
  this.push(mst);

  callback();
};

module.exports = LocalPathBuilder;
