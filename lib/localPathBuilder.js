var stream = require('stream');
var util = require('util');
var Client = require('lc-client');
var async = require('async');
var Fetcher = require('lc-client').Fetcher;
var Planner = require('csa').BasicCSA;

/**
  * A local path builder transforms an MST generated by CSA to a compacted
  * MST representation. Each path in this compacted MST corresponds with a
  * scalable transfer pattern (both local and between border stations, long
  * distance stations are ignored at the moment).
  */
var LocalPathBuilder = function (stop, inverseClustering, borderStations) {
  stream.Transform.call(this, {objectMode : true});
  this._allConnections = {};
  this._stop = stop;
  this._inverseClustering = inverseClustering;
  this._connectionCounter = 0;
  this._borderStations = borderStations;
};

util.inherits(LocalPathBuilder, stream.Transform);

LocalPathBuilder.prototype._write = function (connection, encoding, done) {
  // We simply build an array of connections, which we will then use to generate
  // all possible paths.
  // TODO we can already filter some connections at this point!
  this._allConnections[connection["@id"]] = connection;
  this._connectionCounter++;
  done();
};

// We do not follow all paths in the MST. If the departure stop is not a
// border station, then we only calculate the optimal route to other stations
// in the same cluster. Otherwise, we also calculate the optimal route to
// border stations of other clusters.
LocalPathBuilder.prototype._shouldFollowPath = function (stop1, stop2) {
  if (!this._borderStations[stop1]) {
    return this._inverseClustering[stop1] == this._inverseClustering[stop2];
  } else {
    return this._borderStations[stop2] ||
           this._inverseClustering[stop1] == this._inverseClustering[stop2];
  }
}

LocalPathBuilder.prototype._flush = function (callback) {
  console.log('building local paths with ' + this._connectionCounter + ' connections');

  // Will hold the compacted MST.
  var mst = {};

  // this._allConnections now holds a *full* MST for departure stop this._stop.
  // We will now prune this MST.

  // TODO more comments

  for (var connectionId in this._allConnections) {
    var previousTripId = null;
    var currentConnection = this._allConnections[connectionId];
    var currentPath = [];

    var valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);
    var finished = this._stop == currentConnection.departureStop;

    while (valid && !finished) {
      if (currentConnection["gtfs:trip"]["@id"] != previousTripId) {
        currentPath.push(currentConnection.arrivalStop);
        previousTripId = currentConnection["gtfs:trip"]["@id"];
      }

      if (mst[currentConnection.arrivalStop] != undefined) {
        valid = true;
        finished = true;
      } else {
        currentConnection = this._allConnections[currentConnection.previous];

        // This check is done purely as a safety guard, should we receive a
        // forest instead of a tree as input.
        if (currentConnection === undefined) {
          valid = false;
          finished = false;
        } else {
          valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);
          finished = this._stop == currentConnection.departureStop;
        }
      }
    }

    if (finished && valid) {
      // Two directly connected stops (edge case).
      if (currentPath.length === 0) {
        mst[currentConnection.arrivalStop] = this._stop;
      } else {
        var changedCluster = false;
        currentPath.push(this._stop);
        for (var i = 0; i < currentPath.length - 1; i++) {
          if (this._inverseClustering[this._stop] != this._inverseClustering[currentPath[i]]) {
            changedCluster = true;
          }
          mst[currentPath[i]] = currentPath[i+1];
        }
        this.push(currentPath);

        if (changedCluster &&
            this._inverseClustering[currentPath[0]] === this._inverseClustering[this._stop]) {
            console.log('cluster ' + this._inverseClustering[this._stop] + ' is not convex!');
        }
      }
      //console.log(currentPath);
    }
  }

  //console.log(mst);
  //this.push(mst);

  callback();
};

module.exports = LocalPathBuilder;
