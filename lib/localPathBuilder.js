var stream = require('stream'),
    util = require('util');

/**
  * A transfer pattern builder transforms an MST generated by CSA to transfer
  * patterns for intra-cluster transport and also for transport to and from border
  * stations. The concept of a "long-distance station" is ignored at the moment.
  * The input of this stream consists of connections, as generated by BasicCSA.
  * The output objects will have the following form:
  * tp: the transfer pattern itself, which is just an array of stops.
  * changedCluster: a boolean indicating wether this transfer pattern crosses cluster boundaries
  * stop: the root node of  the MST (corresponding to the "stop" parameter of this constructor)
  * @param stop This should be the root of the MST (corresponds to the departureStop parameter of BasicCSA).
  * @param inverseClustering Mapping of stop id to cluster id
  * @param borderStations Mapping of stop id to boolean, indicating if the corresponding station is classified as a border station.
  */
var TransferPatternBuilder = function (stop, inverseClustering, borderStations) {
  stream.Transform.call(this, {objectMode : true});
  this._allConnections = {};
  this._stop = stop;
  this._inverseClustering = inverseClustering;
  this._borderStations = borderStations;
  this._connectionCounter = 0;
};

util.inherits(TransferPatternBuilder, stream.Transform);

TransferPatternBuilder.prototype._write = function (connection, encoding, done) {
  // Since we need to process the MST as a whole, we simply build an array of
  // all connections.
  // TODO suggestion for optimization: we can already filter some connections at this point!
  this._allConnections[connection["@id"]] = connection;
  this._connectionCounter++;
  done();
};

// We do not follow all paths in the MST. If the departure stop is not a
// border station, then we only calculate the optimal route to other stations
// in the same cluster (we completely ignore stations in other clusters).
// Otherwise, we also calculate the optimal route to border stations of other
// clusters.
TransferPatternBuilder.prototype._shouldFollowPath = function (stop1, stop2) {
  if (this._borderStations[stop1]) {
    return true;
  } else {
    return this._inverseClustering[stop1] == this._inverseClustering[stop2];
  }
}

TransferPatternBuilder.prototype._flush = function (callback) {
  // Will hold a "compressed" version of the MST (only transfer stations).
  var mst = {};
  // Mapping of stop id to boolean, indicating if the optimal path from then
  // corresponding stop to this._stop traverses another cluster.
  var mstChangedCluster = {};

  // this._allConnections now holds a *full* MST for departure stop this._stop.
  // We will now prune this MST by scanning every path. The path is given
  // by the previous-pointers in the connection data.
  for (var connectionId in this._allConnections) {
    // We will now follow the path starting from the connection with
    // connectionId.
    var previousTripId = null;
    var currentConnection = this._allConnections[connectionId];
    var currentPath = []; // will hold a transfer pattern path

    // Not every path in the MST should be saved as a transfer pattern.
    // The definition of a valid path was given earlier.
    var valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);

    // For border stations: only calculate routes to other border stations or
    // stops in the same cluster.
    if (this._borderStations[this._stop] && !this._borderStations[currentConnection.arrivalStop] &&
        this._inverseClustering[this._stop] != this._inverseClustering[currentConnection.arrivalStop]) {
      valid = false;
    }

    // We cannot proceed "past" the root node of the MST, this._stop is the root.
    var finished = this._stop == currentConnection.departureStop;

    var reuse = false;
    // Does using this connection imply a change of clusters?
    var changedCluster = this._inverseClustering[currentConnection.arrivalStop] !=
                         this._inverseClustering[currentConnection.departureStop];

    currentPath.push(currentConnection.arrivalStop); // starting point
    previousTripId = currentConnection["gtfs:trip"]["@id"];

    while (valid && !finished) {
      // We already calculated the transfer patterns starting from
      // currentConnection.arrivalStop. We may reuse this path, since there
      // is only one path to the root (by the definition of "tree").
      if (mst[currentConnection.arrivalStop] != undefined) {
        valid = true;
        finished = true;
        reuse = true;
        currentPath.push(mst[currentConnection.arrivalStop]);
        // changedCluster applies to the *whole* path to the root!
        if (mstChangedCluster[currentConnection.arrivalStop]) {
          changedCluster = true;
        }
      } else {
        // No transfer occured and we are not yet at the root node, so move
        // to the next (= previous) connection and check if this is a valid
        // move.
        var prevtemp = currentConnection;
        currentConnection = this._allConnections[currentConnection.previous];

        // previous undefined implies we are at the root
        if (currentConnection === undefined) {
          valid = this._stop == prevtemp.departureStop;
          if (!valid) console.error('>>>>>> PARTIAL PATH DETECTED FOR STOP '  + this._stop + ' (' + prevtemp.departureStop + ')<<<<<<<');
          finished = true;
        } else {
          if (!changedCluster)
            changedCluster = this._inverseClustering[currentConnection.arrivalStop] !=
                             this._inverseClustering[currentConnection.departureStop];

          // A transfer occured! Add the transfer station to the transfer pattern path.
          if (currentConnection["gtfs:trip"]["@id"] != previousTripId) {
            currentPath.push(currentConnection.arrivalStop);
            previousTripId = currentConnection["gtfs:trip"]["@id"];
          }

          valid = this._shouldFollowPath(this._stop, currentConnection.arrivalStop);
          finished = this._stop == currentConnection.departureStop;
        }
      }
    }

    // Have we found a valid and complete path?
    if (finished && valid) {
      // Write out the current path and save it in the MST structure.
      if (!reuse)
        currentPath.push(this._stop);

      for (var i = 0; i < currentPath.length - 1; i++) {
        mst[currentPath[i]] = currentPath[i+1];
        mstChangedCluster[currentPath[i]] = changedCluster;
      }

      this.push({tp: currentPath, "changedCluster": changedCluster, stop: this._stop});
    }
  }

  callback();
};

module.exports = TransferPatternBuilder;
