var stream = require('stream');
var util = require('util');
var Client = require('lc-client');
var async = require('async');
var Fetcher = require('lc-client').Fetcher;
var Planner = require('csa').BasicCSA;

/**
  * A local path builder transforms the MST as generated by CSA to
  * time-independent *local* transfer patterns. These transfer patterns may
  * then be used to construct the full local transfer pattern DAG.
  */
var LocalPathBuilder = function (stop, inverseClustering) {
  stream.Transform.call(this, {objectMode : true});
  this._allConnections = {};
  this._stop = stop;
  this._inverseClustering = inverseClustering;
  this._connectionCounter = 0;
};

util.inherits(LocalPathBuilder, stream.Transform);

LocalPathBuilder.prototype._write = function (connection, encoding, done) {
  // We simply build an array of connections, which we will then use to generate
  // all possible paths.
  this._allConnections[connection["@id"]] = connection;
  this._connectionCounter++;
  done();
};

LocalPathBuilder.prototype._flush = function (callback) {
  console.log('building local paths with ' + this._connectionCounter + ' connections');

  // We now transform the array of connections to a transfer pattern
  // representation. We map each stop S to the next transfer stop on the reverse
  // path from the departure stop to S.
  // We do this by following the chain of "previous" pointers as long as the
  // following conditions hold:
  // (1) the trip remains the same, e.g. there has not been any transfer
  // (2) we do not go outside the cluster of the departure stop
  // (3) we do not reach a "dead end" in the MST
  // In case (1) isn't satisfied, we update our mapping of stops to the next
  // transfer stop. In case (2) or (3) isn't true, we stop following the chain
  // of "previous"-pointers.
  // Note that we make use of the fact that one stop can never occur multiple
  // times as the arrival stop of a MST connection.
  // TODO verify that this is really true.
  var mst = {};
  var allConnections = this._allConnections;
  var stop = this._stop;

  for (var c in allConnections) {
    var linkDeparture = allConnections[c].arrivalStop;

    // Do not go outside the departure cluster.
    if (this._inverseClustering[linkDeparture] != this._inverseClustering[stop]) {
      continue;
    }
    var currentConnection = allConnections[c];

    while (true) {
      // Arriving at the departure stop also indicates a transfer
      if (currentConnection.previous == null) {
        mst[linkDeparture] = currentConnection.departureStop;
        break;
      }

      var previousConnection = allConnections[currentConnection.previous];

      // We have encountered a dead end, meaning we can never reach the departure
      // stop starting from the departure stop of the first connection in this
      // path.
      if (previousConnection === undefined) {
        break;
      }

      var linkArrival = previousConnection.departureStop;

      // Do not go outside the departure cluster.
      if (this._inverseClustering[linkArrival] != this._inverseClustering[stop]) {
        break;
      }

      // To get to this connection, we need to transfer at
      // previousConnection.arrivalStop == currentConnection.departureStop.
      // So this is the transfer station.
      if (currentConnection["gtfs:trip"]["@id"] != previousConnection["gtfs:trip"]["@id"]) {
        mst[linkDeparture] = previousConnection.arrivalStop;
        break;
      } else {
        // If we already know the next transfer stop starting
        // from the current linkArrival, then we may stop
        // looping as well.
        if (mst[linkArrival] != undefined) {
          mst[linkDeparture] = mst[linkArrival];
          break;
        } else {
          currentConnection = previousConnection;
        }
      }
    }
  }

  // Our transfer pattern representation is not fully correct yet. Starting
  // from a certain stop and following the chain of transfer stops may lead
  // to a dead end, meaning the departure stop is unreachable without for
  // example leaving the current cluster. Therefore we need to do a DFS on
  // the transfer patterns starting from each departure stop. When we reach
  // the departure stop, we write out the path to the departure stop. This
  // path may then be further processed by DAGBuilder to build the DAG
  // representation of the transfer patterns.
  // TODO: could be made more efficient by "backtracking" the path in the loop
  // above.
  for (var stop in mst) {
    var path = [];
    var currentStop = stop;
    var valid = true;
    do {
      path.push(currentStop);
      currentStop = mst[currentStop];
      if (currentStop == undefined || this._inverseClustering[currentStop] != this._inverseClustering[this._stop]) {
        valid = false;
      }
    } while (currentStop != this._stop && valid);
    path.push(this._stop);
    if (valid) {
      this.push(path);
      console.log(path);
    }
  }

  callback();
};

module.exports = LocalPathBuilder;
